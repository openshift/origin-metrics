From 7b1a181770a47492ca38c22d991a85c6bd647d9d Mon Sep 17 00:00:00 2001
From: Michael Burman <yak@iki.fi>
Date: Mon, 3 Jul 2017 14:59:35 +0300
Subject: [PATCH 2/2] Update Hawkular-Metrics driver

(cherry picked from commit 114a808374faf2daeabc93b038f4b191a1d8ab5b)
---
 metrics/sinks/hawkular/client.go                   |  10 +-
 metrics/sinks/hawkular/driver_test.go              |  32 +--
 .../hawkular/hawkular-client-go/metrics/client.go  | 309 ++++++++++++++++-----
 .../hawkular/hawkular-client-go/metrics/helpers.go |  11 +-
 .../hawkular/hawkular-client-go/metrics/types.go   | 179 ++++++------
 5 files changed, 362 insertions(+), 179 deletions(-)

diff --git a/metrics/sinks/hawkular/client.go b/metrics/sinks/hawkular/client.go
index 764e389..f224692 100644
--- a/metrics/sinks/hawkular/client.go
+++ b/metrics/sinks/hawkular/client.go
@@ -46,11 +46,11 @@ func (h *hawkularSink) updateDefinitions(mt metrics.MetricType) error {
 		// If no descriptorTag is found, this metric does not belong to Heapster
 		if mk, found := p.Tags[descriptorTag]; found {
 			if model, f := h.models[mk]; f && !h.recent(p, model) {
-				if err := h.client.UpdateTags(mt, p.Id, p.Tags, h.modifiers...); err != nil {
+				if err := h.client.UpdateTags(mt, p.ID, p.Tags, h.modifiers...); err != nil {
 					return err
 				}
 			}
-			h.reg[p.Id] = p
+			h.reg[p.ID] = p
 		}
 	}
 
@@ -88,7 +88,7 @@ func (h *hawkularSink) descriptorToDefinition(md *core.MetricDescriptor) metrics
 	tags[descriptorTag] = md.Name
 
 	hmd := metrics.MetricDefinition{
-		Id:   md.Name,
+		ID:   md.Name,
 		Tags: tags,
 		Type: heapsterTypeToHawkularType(md.Type),
 	}
@@ -287,11 +287,11 @@ func (h *hawkularSink) pointToLabeledMetricHeader(ms *core.MetricSet, metric cor
 
 	m := metrics.Datapoint{
 		Value:     value,
-		Timestamp: metrics.UnixMilli(timestamp),
+		Timestamp: timestamp,
 	}
 
 	mh := &metrics.MetricHeader{
-		Id:   name,
+		ID:   name,
 		Data: []metrics.Datapoint{m},
 		Type: heapsterTypeToHawkularType(metric.MetricType),
 	}
diff --git a/metrics/sinks/hawkular/driver_test.go b/metrics/sinks/hawkular/driver_test.go
index 25c131c..1d8cfe7 100644
--- a/metrics/sinks/hawkular/driver_test.go
+++ b/metrics/sinks/hawkular/driver_test.go
@@ -57,7 +57,7 @@ func TestDescriptorTransform(t *testing.T) {
 
 	md := hSink.descriptorToDefinition(&smd)
 
-	assert.Equal(t, smd.Name, md.Id)
+	assert.Equal(t, smd.Name, md.ID)
 	assert.Equal(t, 3, len(md.Tags)) // descriptorTag, unitsTag, typesTag, k1
 
 	assert.Equal(t, smd.Units.String(), md.Tags[unitsTag])
@@ -122,7 +122,7 @@ func TestMetricTransform(t *testing.T) {
 	assert.NoError(t, err)
 
 	assert.Equal(t, fmt.Sprintf("%s/%s/%s", metricSet.Labels[core.LabelContainerName.Key],
-		metricSet.Labels[core.LabelPodId.Key], metricName), m.Id)
+		metricSet.Labels[core.LabelPodId.Key], metricName), m.ID)
 
 	assert.Equal(t, 1, len(m.Data))
 	_, ok := m.Data[0].Value.(float64)
@@ -134,7 +134,7 @@ func TestMetricTransform(t *testing.T) {
 	m, err = hSink.pointToLabeledMetricHeader(&metricSet, metricSet.LabeledMetrics[2], now)
 	assert.NoError(t, err)
 
-	assert.Equal(t, fmt.Sprintf("%s/%s/%s", metricSet.Labels[core.LabelContainerName.Key], metricSet.Labels[core.LabelNodename.Key], metricName), m.Id)
+	assert.Equal(t, fmt.Sprintf("%s/%s/%s", metricSet.Labels[core.LabelContainerName.Key], metricSet.Labels[core.LabelNodename.Key], metricName), m.ID)
 
 	//
 	m, err = hSink.pointToLabeledMetricHeader(&metricSet, metricSet.LabeledMetrics[0], now)
@@ -142,13 +142,13 @@ func TestMetricTransform(t *testing.T) {
 
 	assert.Equal(t, fmt.Sprintf("%s/%s/%s/%s", metricSet.Labels[core.LabelContainerName.Key],
 		metricSet.Labels[core.LabelNodename.Key], labeledMetricNameA,
-		metricSet.LabeledMetrics[0].Labels[core.LabelResourceID.Key]), m.Id)
+		metricSet.LabeledMetrics[0].Labels[core.LabelResourceID.Key]), m.ID)
 
 	//
 	m, err = hSink.pointToLabeledMetricHeader(&metricSet, metricSet.LabeledMetrics[1], now)
 	assert.NoError(t, err)
 	assert.Equal(t, fmt.Sprintf("%s/%s/%s", metricSet.Labels[core.LabelContainerName.Key],
-		metricSet.Labels[core.LabelNodename.Key], labeledMetricNameB), m.Id)
+		metricSet.Labels[core.LabelNodename.Key], labeledMetricNameB), m.ID)
 }
 
 func TestMetricIds(t *testing.T) {
@@ -181,43 +181,43 @@ func TestMetricIds(t *testing.T) {
 	//
 	m, err := hSink.pointToLabeledMetricHeader(&metricSet, metricSet.LabeledMetrics[0], now)
 	assert.NoError(t, err)
-	assert.Equal(t, fmt.Sprintf("%s/%s/%s", metricSet.Labels[core.LabelContainerName.Key], metricSet.Labels[core.LabelPodId.Key], metricName), m.Id)
+	assert.Equal(t, fmt.Sprintf("%s/%s/%s", metricSet.Labels[core.LabelContainerName.Key], metricSet.Labels[core.LabelPodId.Key], metricName), m.ID)
 
 	//
 	metricSet.Labels[core.LabelMetricSetType.Key] = core.MetricSetTypeNode
 	m, err = hSink.pointToLabeledMetricHeader(&metricSet, metricSet.LabeledMetrics[0], now)
 	assert.NoError(t, err)
-	assert.Equal(t, fmt.Sprintf("%s/%s/%s", "machine", metricSet.Labels[core.LabelNodename.Key], metricName), m.Id)
+	assert.Equal(t, fmt.Sprintf("%s/%s/%s", "machine", metricSet.Labels[core.LabelNodename.Key], metricName), m.ID)
 
 	//
 	metricSet.Labels[core.LabelMetricSetType.Key] = core.MetricSetTypePod
 	m, err = hSink.pointToLabeledMetricHeader(&metricSet, metricSet.LabeledMetrics[0], now)
 	assert.NoError(t, err)
-	assert.Equal(t, fmt.Sprintf("%s/%s/%s", core.MetricSetTypePod, metricSet.Labels[core.LabelPodId.Key], metricName), m.Id)
+	assert.Equal(t, fmt.Sprintf("%s/%s/%s", core.MetricSetTypePod, metricSet.Labels[core.LabelPodId.Key], metricName), m.ID)
 
 	//
 	metricSet.Labels[core.LabelMetricSetType.Key] = core.MetricSetTypePodContainer
 	m, err = hSink.pointToLabeledMetricHeader(&metricSet, metricSet.LabeledMetrics[0], now)
 	assert.NoError(t, err)
-	assert.Equal(t, fmt.Sprintf("%s/%s/%s", metricSet.Labels[core.LabelContainerName.Key], metricSet.Labels[core.LabelPodId.Key], metricName), m.Id)
+	assert.Equal(t, fmt.Sprintf("%s/%s/%s", metricSet.Labels[core.LabelContainerName.Key], metricSet.Labels[core.LabelPodId.Key], metricName), m.ID)
 
 	//
 	metricSet.Labels[core.LabelMetricSetType.Key] = core.MetricSetTypeSystemContainer
 	m, err = hSink.pointToLabeledMetricHeader(&metricSet, metricSet.LabeledMetrics[0], now)
 	assert.NoError(t, err)
-	assert.Equal(t, fmt.Sprintf("%s/%s/%s/%s", core.MetricSetTypeSystemContainer, metricSet.Labels[core.LabelContainerName.Key], metricSet.Labels[core.LabelPodId.Key], metricName), m.Id)
+	assert.Equal(t, fmt.Sprintf("%s/%s/%s/%s", core.MetricSetTypeSystemContainer, metricSet.Labels[core.LabelContainerName.Key], metricSet.Labels[core.LabelPodId.Key], metricName), m.ID)
 
 	//
 	metricSet.Labels[core.LabelMetricSetType.Key] = core.MetricSetTypeCluster
 	m, err = hSink.pointToLabeledMetricHeader(&metricSet, metricSet.LabeledMetrics[0], now)
 	assert.NoError(t, err)
-	assert.Equal(t, fmt.Sprintf("%s/%s", core.MetricSetTypeCluster, metricName), m.Id)
+	assert.Equal(t, fmt.Sprintf("%s/%s", core.MetricSetTypeCluster, metricName), m.ID)
 
 	//
 	metricSet.Labels[core.LabelMetricSetType.Key] = core.MetricSetTypeNamespace
 	m, err = hSink.pointToLabeledMetricHeader(&metricSet, metricSet.LabeledMetrics[0], now)
 	assert.NoError(t, err)
-	assert.Equal(t, fmt.Sprintf("%s/%s/%s", core.MetricSetTypeNamespace, metricSet.Labels[core.LabelNamespaceName.Key], metricName), m.Id)
+	assert.Equal(t, fmt.Sprintf("%s/%s/%s", core.MetricSetTypeNamespace, metricSet.Labels[core.LabelNamespaceName.Key], metricName), m.ID)
 
 }
 
@@ -232,7 +232,7 @@ func TestRecentTest(t *testing.T) {
 	modelT["hep"+descriptionTag] = "n"
 
 	model := metrics.MetricDefinition{
-		Id:   id,
+		ID:   id,
 		Tags: modelT,
 	}
 
@@ -242,7 +242,7 @@ func TestRecentTest(t *testing.T) {
 	}
 
 	live := metrics.MetricDefinition{
-		Id:   "test/" + id,
+		ID:   "test/" + id,
 		Tags: liveT,
 	}
 
@@ -421,7 +421,7 @@ func TestStoreTimeseries(t *testing.T) {
 
 		assert.Equal(t, 1, len(mH))
 
-		ids = append(ids, mH[0].Id)
+		ids = append(ids, mH[0].ID)
 	}))
 	defer s.Close()
 
@@ -753,7 +753,7 @@ func TestBatchingTimeseries(t *testing.T) {
 		assert.NoError(t, err)
 
 		for _, v := range mH {
-			ids = append(ids, v.Id)
+			ids = append(ids, v.ID)
 		}
 
 		calls++
diff --git a/vendor/github.com/hawkular/hawkular-client-go/metrics/client.go b/vendor/github.com/hawkular/hawkular-client-go/metrics/client.go
index 2502b1a..89925cc 100644
--- a/vendor/github.com/hawkular/hawkular-client-go/metrics/client.go
+++ b/vendor/github.com/hawkular/hawkular-client-go/metrics/client.go
@@ -1,5 +1,5 @@
 /*
-   Copyright 2015-2016 Red Hat, Inc. and/or its affiliates
+   Copyright 2015-2017 Red Hat, Inc. and/or its affiliates
    and other contributors.
 
    Licensed under the Apache License, Version 2.0 (the "License");
@@ -19,6 +19,7 @@ package metrics
 
 import (
 	"bytes"
+	"encoding/base64"
 	"encoding/json"
 	"fmt"
 	"io/ioutil"
@@ -30,8 +31,6 @@ import (
 	"time"
 )
 
-// TODO Instrumentation? To get statistics?
-
 func (c *HawkularClientError) Error() string {
 	return fmt.Sprintf("Hawkular returned status code %d, error message: %s", c.Code, c.msg)
 }
@@ -42,17 +41,27 @@ const (
 	baseURL            string        = "hawkular/metrics"
 	defaultConcurrency int           = 1
 	timeout            time.Duration = time.Duration(30 * time.Second)
+	tenantHeader       string        = "Hawkular-Tenant"
+	adminHeader        string        = "Hawkular-Admin-Token"
 )
 
-// Tenant Override function to replace the Tenant (defaults to Client default)
+// Tenant function replaces the Tenant in the request (instead of using the default in Client parameters)
 func Tenant(tenant string) Modifier {
 	return func(r *http.Request) error {
-		r.Header.Set("Hawkular-Tenant", tenant)
+		r.Header.Set(tenantHeader, tenant)
 		return nil
 	}
 }
 
-// Data Add payload to the request
+// AdminAuthentication function to add metrics' admin token to the request
+func AdminAuthentication(token string) Modifier {
+	return func(r *http.Request) error {
+		r.Header.Add(adminHeader, token)
+		return nil
+	}
+}
+
+// Data adds payload to the request
 func Data(data interface{}) Modifier {
 	return func(r *http.Request) error {
 		jsonb, err := json.Marshal(data)
@@ -64,8 +73,6 @@ func Data(data interface{}) Modifier {
 		rc := ioutil.NopCloser(b)
 		r.Body = rc
 
-		// fmt.Printf("Sending: %s\n", string(jsonb))
-
 		if b != nil {
 			r.ContentLength = int64(b.Len())
 		}
@@ -73,9 +80,10 @@ func Data(data interface{}) Modifier {
 	}
 }
 
-// URL Set the request URL
-func (c *Client) Url(method string, e ...Endpoint) Modifier {
+// URL sets the request URL
+func (c *Client) URL(method string, e ...Endpoint) Modifier {
 	// TODO Create composite URLs? Add().Add().. etc? Easier to modify on the fly..
+	// And also remove the necessary order of Adds
 	return func(r *http.Request) error {
 		u := c.createURL(e...)
 		r.URL = u
@@ -84,7 +92,7 @@ func (c *Client) Url(method string, e ...Endpoint) Modifier {
 	}
 }
 
-// Filters Multiple Filter types to execute
+// Filters allows using multiple Filter types in the same request
 func Filters(f ...Filter) Modifier {
 	return func(r *http.Request) error {
 		for _, filter := range f {
@@ -94,7 +102,7 @@ func Filters(f ...Filter) Modifier {
 	}
 }
 
-// Param Add query parameters
+// Param adds query parameters to the request
 func Param(k string, v string) Filter {
 	return func(r *http.Request) {
 		q := r.URL.Query()
@@ -103,38 +111,51 @@ func Param(k string, v string) Filter {
 	}
 }
 
-// TypeFilter Query parameter filtering with type
+// TypeFilter is a query parameter to filter by type
 func TypeFilter(t MetricType) Filter {
-	return Param("type", t.shortForm())
+	return Param("type", fmt.Sprint(t))
 }
 
-// TagsFilter Query parameter filtering with tags
+// TagsFilter is a query parameter to filter with tags query
 func TagsFilter(t map[string]string) Filter {
-	j := tagsEncoder(t)
+	j := tagsEncoder(t, false)
 	return Param("tags", j)
 }
 
-// IdFilter Query parameter to add filtering by id name
+// TagsQueryFilter is a query parameter for the new style tags query language
+func TagsQueryFilter(query ...string) Filter {
+	tagQl := strings.Join(query, " AND ")
+	return Param("tags", tagQl)
+}
+
+// IdFilter is a query parameter to add filtering by id name
 func IdFilter(regexp string) Filter {
 	return Param("id", regexp)
 }
 
-// StartTimeFilter Query parameter to filter with start time
+// StartTimeFilter is a query parameter to filter with start time
 func StartTimeFilter(startTime time.Time) Filter {
-	return Param("start", strconv.Itoa(int(startTime.Unix())))
+	// return Param("start", strconv.Itoa(int(startTime.Unix())))
+	return Param("start", strconv.Itoa(int(ToUnixMilli(startTime))))
 }
 
-// EndTimeFilter Query parameter to filter with end time
+// EndTimeFilter is a query parameter to filter with end time
 func EndTimeFilter(endTime time.Time) Filter {
-	return Param("end", strconv.Itoa(int(endTime.Unix())))
+	return Param("end", strconv.Itoa(int(ToUnixMilli(endTime))))
 }
 
-// BucketsFilter Query parameter to define amount of buckets
+// BucketsFilter is a query parameter to define amount of buckets
 func BucketsFilter(buckets int) Filter {
 	return Param("buckets", strconv.Itoa(buckets))
 }
 
-// LimitFilter Query parameter to limit result count
+// BucketsDurationFilter is a query parameter to set the size of a bucket based on duration
+// Minimum supported bucket is 1 millisecond
+func BucketsDurationFilter(duration time.Duration) Filter {
+	return Param("bucketDuration", fmt.Sprintf("%dms", (duration.Nanoseconds()/1e6)))
+}
+
+// LimitFilter is a query parameter to limit result count
 func LimitFilter(limit int) Filter {
 	return Param("limit", strconv.Itoa(limit))
 }
@@ -144,17 +165,17 @@ func OrderFilter(order Order) Filter {
 	return Param("order", order.String())
 }
 
-// StartFromBeginningFilter Return data from the oldest stored datapoint
+// StartFromBeginningFilter returns data from the oldest stored datapoint
 func StartFromBeginningFilter() Filter {
 	return Param("fromEarliest", "true")
 }
 
-// StackedFilter Force downsampling of stacked return values
+// StackedFilter forces downsampling of stacked return values
 func StackedFilter() Filter {
 	return Param("stacked", "true")
 }
 
-// PercentilesFilter Query parameter to define the requested percentiles
+// PercentilesFilter is a query parameter to define the requested percentiles
 func PercentilesFilter(percentiles []float64) Filter {
 	s := make([]string, 0, len(percentiles))
 	for _, v := range percentiles {
@@ -175,7 +196,11 @@ func (c *Client) createRequest() *http.Request {
 		Host:       c.url.Host,
 	}
 	req.Header.Add("Content-Type", "application/json")
-	req.Header.Add("Hawkular-Tenant", c.Tenant)
+	req.Header.Add(tenantHeader, c.Tenant)
+
+	if len(c.Credentials) > 0 {
+		req.Header.Add("Authorization", fmt.Sprintf("Basic %s", c.Credentials))
+	}
 
 	if len(c.Token) > 0 {
 		req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", c.Token))
@@ -184,7 +209,8 @@ func (c *Client) createRequest() *http.Request {
 	return req
 }
 
-// Send Sends a constructed request to the Hawkular-Metrics server
+// Send sends a constructed request to the Hawkular-Metrics server.
+// All the requests are pooled and limited by set concurrency limits
 func (c *Client) Send(o ...Modifier) (*http.Response, error) {
 	// Initialize
 	r := c.createRequest()
@@ -210,10 +236,64 @@ func (c *Client) Send(o ...Modifier) (*http.Response, error) {
 
 // Commands
 
-// Create Creates new metric Definition
+// Tenants returns a list of tenants from the server
+func (c *Client) Tenants(o ...Modifier) ([]*TenantDefinition, error) {
+	o = prepend(o, c.URL("GET", TenantEndpoint()), AdminAuthentication(c.AdminToken))
+
+	r, err := c.Send(o...)
+	if err != nil {
+		return nil, err
+	}
+
+	defer r.Body.Close()
+
+	if r.StatusCode == http.StatusOK {
+		b, err := ioutil.ReadAll(r.Body)
+		if err != nil {
+			return nil, err
+		}
+		tenants := []*TenantDefinition{}
+		if b != nil {
+			if err = json.Unmarshal(b, &tenants); err != nil {
+				return nil, err
+			}
+		}
+		return tenants, err
+	} else if r.StatusCode > 399 {
+		return nil, c.parseErrorResponse(r)
+	}
+
+	return nil, nil
+}
+
+// CreateTenant creates a tenant definition on the server
+func (c *Client) CreateTenant(tenant TenantDefinition, o ...Modifier) (bool, error) {
+	o = prepend(o, c.URL("POST", TenantEndpoint()), AdminAuthentication(c.AdminToken), Data(tenant))
+
+	r, err := c.Send(o...)
+	if err != nil {
+		return false, err
+	}
+
+	defer r.Body.Close()
+
+	if r.StatusCode > 399 {
+		err = c.parseErrorResponse(r)
+		if err, ok := err.(*HawkularClientError); ok {
+			if err.Code != http.StatusConflict {
+				return false, err
+			}
+			return false, nil
+		}
+		return false, err
+	}
+	return true, nil
+}
+
+// Create creates a new metric definition
 func (c *Client) Create(md MetricDefinition, o ...Modifier) (bool, error) {
 	// Keep the order, add custom prepend
-	o = prepend(o, c.Url("POST", TypeEndpoint(md.Type)), Data(md))
+	o = prepend(o, c.URL("POST", TypeEndpoint(md.Type)), Data(md))
 
 	r, err := c.Send(o...)
 	if err != nil {
@@ -227,18 +307,17 @@ func (c *Client) Create(md MetricDefinition, o ...Modifier) (bool, error) {
 		if err, ok := err.(*HawkularClientError); ok {
 			if err.Code != http.StatusConflict {
 				return false, err
-			} else {
-				return false, nil
 			}
+			return false, nil
 		}
 		return false, err
 	}
 	return true, nil
 }
 
-// Definitions Fetch metric definitions
+// Definitions fetches metric definitions from the server
 func (c *Client) Definitions(o ...Modifier) ([]*MetricDefinition, error) {
-	o = prepend(o, c.Url("GET", TypeEndpoint(Generic)))
+	o = prepend(o, c.URL("GET", TypeEndpoint(Generic)))
 
 	r, err := c.Send(o...)
 	if err != nil {
@@ -266,9 +345,9 @@ func (c *Client) Definitions(o ...Modifier) ([]*MetricDefinition, error) {
 	return nil, nil
 }
 
-// Definition Return a single definition
+// Definition returns a single metric definition
 func (c *Client) Definition(t MetricType, id string, o ...Modifier) (*MetricDefinition, error) {
-	o = prepend(o, c.Url("GET", TypeEndpoint(t), SingleMetricEndpoint(id)))
+	o = prepend(o, c.URL("GET", TypeEndpoint(t), SingleMetricEndpoint(id)))
 
 	r, err := c.Send(o...)
 	if err != nil {
@@ -296,9 +375,39 @@ func (c *Client) Definition(t MetricType, id string, o ...Modifier) (*MetricDefi
 	return nil, nil
 }
 
-// UpdateTags Update tags of a metric (or create if not existing)
+// TagValues queries for available tagValues
+func (c *Client) TagValues(tagQuery map[string]string, o ...Modifier) (map[string][]string, error) {
+	o = prepend(o, c.URL("GET", TypeEndpoint(Generic), TagEndpoint(), TagsEndpoint(tagQuery)))
+
+	r, err := c.Send(o...)
+	if err != nil {
+		return nil, err
+	}
+
+	defer r.Body.Close()
+
+	if r.StatusCode == http.StatusOK {
+		b, err := ioutil.ReadAll(r.Body)
+		if err != nil {
+			return nil, err
+		}
+		md := make(map[string][]string)
+		if b != nil {
+			if err = json.Unmarshal(b, &md); err != nil {
+				return nil, err
+			}
+		}
+		return md, err
+	} else if r.StatusCode > 399 {
+		return nil, c.parseErrorResponse(r)
+	}
+
+	return nil, nil
+}
+
+// UpdateTags modifies the tags of a metric definition
 func (c *Client) UpdateTags(t MetricType, id string, tags map[string]string, o ...Modifier) error {
-	o = prepend(o, c.Url("PUT", TypeEndpoint(t), SingleMetricEndpoint(id), TagEndpoint()), Data(tags))
+	o = prepend(o, c.URL("PUT", TypeEndpoint(t), SingleMetricEndpoint(id), TagEndpoint()), Data(tags))
 
 	r, err := c.Send(o...)
 	if err != nil {
@@ -314,9 +423,9 @@ func (c *Client) UpdateTags(t MetricType, id string, tags map[string]string, o .
 	return nil
 }
 
-// DeleteTags Delete given tags from the definition
-func (c *Client) DeleteTags(t MetricType, id string, tags map[string]string, o ...Modifier) error {
-	o = prepend(o, c.Url("DELETE", TypeEndpoint(t), SingleMetricEndpoint(id), TagEndpoint(), TagsEndpoint(tags)))
+// DeleteTags deletes given tags from the definition
+func (c *Client) DeleteTags(t MetricType, id string, tags []string, o ...Modifier) error {
+	o = prepend(o, c.URL("DELETE", TypeEndpoint(t), SingleMetricEndpoint(id), TagEndpoint(), TagNamesEndpoint(tags)))
 
 	r, err := c.Send(o...)
 	if err != nil {
@@ -332,9 +441,9 @@ func (c *Client) DeleteTags(t MetricType, id string, tags map[string]string, o .
 	return nil
 }
 
-// Tags Fetch metric definition's tags
+// Tags fetches metric definition's tags
 func (c *Client) Tags(t MetricType, id string, o ...Modifier) (map[string]string, error) {
-	o = prepend(o, c.Url("GET", TypeEndpoint(t), SingleMetricEndpoint(id), TagEndpoint()))
+	o = prepend(o, c.URL("GET", TypeEndpoint(t), SingleMetricEndpoint(id), TagEndpoint()))
 
 	r, err := c.Send(o...)
 	if err != nil {
@@ -362,7 +471,7 @@ func (c *Client) Tags(t MetricType, id string, o ...Modifier) (map[string]string
 	return nil, nil
 }
 
-// Write Write datapoints to the server
+// Write writes datapoints to the server
 func (c *Client) Write(metrics []MetricHeader, o ...Modifier) error {
 	if len(metrics) > 0 {
 		mHs := make(map[MetricType][]MetricHeader)
@@ -383,7 +492,7 @@ func (c *Client) Write(metrics []MetricHeader, o ...Modifier) error {
 
 				// Should be sorted and splitted by type & tenant..
 				on := o
-				on = prepend(on, c.Url("POST", TypeEndpoint(k), DataEndpoint()), Data(v))
+				on = prepend(on, c.URL("POST", TypeEndpoint(k), RawEndpoint()), Data(v))
 
 				r, err := c.Send(on...)
 				if err != nil {
@@ -413,9 +522,9 @@ func (c *Client) Write(metrics []MetricHeader, o ...Modifier) error {
 	return nil
 }
 
-// ReadMetric Read metric datapoints from the server
-func (c *Client) ReadMetric(t MetricType, id string, o ...Modifier) ([]*Datapoint, error) {
-	o = prepend(o, c.Url("GET", TypeEndpoint(t), SingleMetricEndpoint(id), DataEndpoint()))
+// ReadRaw reads metric datapoints from the server for the given metric
+func (c *Client) ReadRaw(t MetricType, id string, o ...Modifier) ([]*Datapoint, error) {
+	o = prepend(o, c.URL("GET", TypeEndpoint(t), SingleMetricEndpoint(id), RawEndpoint()))
 
 	r, err := c.Send(o...)
 	if err != nil {
@@ -430,7 +539,6 @@ func (c *Client) ReadMetric(t MetricType, id string, o ...Modifier) ([]*Datapoin
 			return nil, err
 		}
 
-		// Check for GaugeBucketpoint and so on for the rest.. uh
 		dp := []*Datapoint{}
 		if b != nil {
 			if err = json.Unmarshal(b, &dp); err != nil {
@@ -445,9 +553,9 @@ func (c *Client) ReadMetric(t MetricType, id string, o ...Modifier) ([]*Datapoin
 	return nil, nil
 }
 
-// ReadBuckets Read datapoints from the server with in buckets (aggregates)
+// ReadBuckets reads datapoints from the server, aggregated to buckets with given parameters.
 func (c *Client) ReadBuckets(t MetricType, o ...Modifier) ([]*Bucketpoint, error) {
-	o = prepend(o, c.Url("GET", TypeEndpoint(t), DataEndpoint()))
+	o = prepend(o, c.URL("GET", TypeEndpoint(t), StatsEndpoint()))
 
 	r, err := c.Send(o...)
 	if err != nil {
@@ -477,13 +585,21 @@ func (c *Client) ReadBuckets(t MetricType, o ...Modifier) ([]*Bucketpoint, error
 	return nil, nil
 }
 
-// NewHawkularClient Initialization
+// NewHawkularClient returns a new initialized instance of client
 func NewHawkularClient(p Parameters) (*Client, error) {
 	uri, err := url.Parse(p.Url)
 	if err != nil {
 		return nil, err
 	}
 
+	if (p.Username != "" && p.Password == "") || (p.Username == "" && p.Password != "") {
+		return nil, fmt.Errorf("To configure credentials, you must specify both Username and Password")
+	}
+
+	if (p.Username != "" && p.Password != "") && (p.Token != "") {
+		return nil, fmt.Errorf("You cannot specify both Username/Password credentials and a Token.")
+	}
+
 	if uri.Path == "" {
 		uri.Path = baseURL
 	}
@@ -492,7 +608,7 @@ func NewHawkularClient(p Parameters) (*Client, error) {
 		Host:   uri.Host,
 		Path:   uri.Path,
 		Scheme: uri.Scheme,
-		Opaque: fmt.Sprintf("//%s/%s", uri.Host, uri.Path),
+		Opaque: fmt.Sprintf("/%s", uri.Path),
 	}
 
 	c := &http.Client{
@@ -503,16 +619,23 @@ func NewHawkularClient(p Parameters) (*Client, error) {
 		c.Transport = transport
 	}
 
+	var creds string
+	if p.Username != "" && p.Password != "" {
+		creds = base64.StdEncoding.EncodeToString([]byte(fmt.Sprintf("%v:%v", p.Username, p.Password)))
+	}
+
 	if p.Concurrency < 1 {
 		p.Concurrency = 1
 	}
 
 	client := &Client{
-		url:    u,
-		Tenant: p.Tenant,
-		Token:  p.Token,
-		client: c,
-		pool:   make(chan *poolRequest, p.Concurrency),
+		url:         u,
+		Tenant:      p.Tenant,
+		Credentials: creds,
+		Token:       p.Token,
+		AdminToken:  p.AdminToken,
+		client:      c,
+		pool:        make(chan *poolRequest, p.Concurrency),
 	}
 
 	for i := 0; i < p.Concurrency; i++ {
@@ -522,7 +645,7 @@ func NewHawkularClient(p Parameters) (*Client, error) {
 	return client, nil
 }
 
-// Close Safely close the Hawkular-Metrics client and flush remaining work
+// Close safely closes the Hawkular-Metrics client and flushes remaining writes to the server
 func (c *Client) Close() {
 	close(c.pool)
 }
@@ -562,38 +685,73 @@ func (c *Client) createURL(e ...Endpoint) *url.URL {
 	return &mu
 }
 
-// TypeEndpoint URL endpoint setting metricType
+// TenantEndpoint is a URL endpoint to fetch tenant related information
+func TenantEndpoint() Endpoint {
+	return func(u *url.URL) {
+		addToURL(u, "tenants")
+	}
+}
+
+// TypeEndpoint is a URL endpoint setting metricType
 func TypeEndpoint(t MetricType) Endpoint {
 	return func(u *url.URL) {
-		addToURL(u, t.String())
+		switch t {
+		case Gauge:
+			addToURL(u, "gauges")
+		case Counter:
+			addToURL(u, "counters")
+		case String:
+			addToURL(u, "strings")
+		default:
+			addToURL(u, string(t))
+		}
 	}
 }
 
-// SingleMetricEndpoint URL endpoint for requesting single metricID
+// SingleMetricEndpoint is a URL endpoint for requesting single metricID
 func SingleMetricEndpoint(id string) Endpoint {
 	return func(u *url.URL) {
-		addToURL(u, url.QueryEscape(id))
+		addToURL(u, URLEscape(id))
 	}
 }
 
-// TagEndpoint URL endpoint to check tags information
+// TagEndpoint is a URL endpoint to check tags information
 func TagEndpoint() Endpoint {
 	return func(u *url.URL) {
 		addToURL(u, "tags")
 	}
 }
 
-// TagsEndpoint URL endpoint which adds tags query
+// TagsEndpoint is a URL endpoint which adds tags query
 func TagsEndpoint(tags map[string]string) Endpoint {
 	return func(u *url.URL) {
-		addToURL(u, tagsEncoder(tags))
+		addToURL(u, tagsEncoder(tags, true))
 	}
 }
 
-// DataEndpoint URL endpoint for inserting / requesting datapoints
-func DataEndpoint() Endpoint {
+// TagNamesEndpoint is a URL endpoint which adds tags names (no values)
+func TagNamesEndpoint(tagNames []string) Endpoint {
 	return func(u *url.URL) {
-		addToURL(u, "data")
+		escapedNames := make([]string, 0, len(tagNames))
+		for _, v := range tagNames {
+			escapedNames = append(escapedNames, URLEscape(v))
+		}
+		tags := strings.Join(escapedNames, ",")
+		addToURL(u, tags)
+	}
+}
+
+// RawEndpoint is an endpoint to read and write raw datapoints
+func RawEndpoint() Endpoint {
+	return func(u *url.URL) {
+		addToURL(u, "raw")
+	}
+}
+
+// StatsEndpoint is an endpoint to read aggregated metrics
+func StatsEndpoint() Endpoint {
+	return func(u *url.URL) {
+		addToURL(u, "stats")
 	}
 }
 
@@ -602,11 +760,22 @@ func addToURL(u *url.URL, s string) *url.URL {
 	return u
 }
 
-func tagsEncoder(t map[string]string) string {
+func tagsEncoder(t map[string]string, escape bool) string {
 	tags := make([]string, 0, len(t))
 	for k, v := range t {
+		if escape {
+			k = URLEscape(k)
+			v = URLEscape(v)
+		}
 		tags = append(tags, fmt.Sprintf("%s:%s", k, v))
 	}
 	j := strings.Join(tags, ",")
 	return j
 }
+
+// URLEscape Is a fixed version of Golang's URL escaping handling
+func URLEscape(input string) string {
+	escaped := url.QueryEscape(input)
+	escaped = strings.Replace(escaped, "+", "%20", -1)
+	return escaped
+}
diff --git a/vendor/github.com/hawkular/hawkular-client-go/metrics/helpers.go b/vendor/github.com/hawkular/hawkular-client-go/metrics/helpers.go
index e621029..31f98bb 100644
--- a/vendor/github.com/hawkular/hawkular-client-go/metrics/helpers.go
+++ b/vendor/github.com/hawkular/hawkular-client-go/metrics/helpers.go
@@ -75,9 +75,14 @@ func ConvertToFloat64(v interface{}) (float64, error) {
 	}
 }
 
-// UnixMilli Returns milliseconds since epoch
-func UnixMilli(t time.Time) int64 {
-	return t.UnixNano() / 1e6
+// ToUnixMilli returns milliseconds since epoch from time.Time
+func ToUnixMilli(t time.Time) int64 {
+	return t.UnixNano() / (int64(time.Millisecond) / int64(time.Nanosecond))
+}
+
+// FromUnixMilli returns time.Time from milliseconds since epoch
+func FromUnixMilli(milli int64) time.Time {
+	return time.Unix(0, milli*int64(time.Millisecond))
 }
 
 // Prepend Helper function to insert modifier in the beginning of slice
diff --git a/vendor/github.com/hawkular/hawkular-client-go/metrics/types.go b/vendor/github.com/hawkular/hawkular-client-go/metrics/types.go
index cd0beb6..0310dc1 100644
--- a/vendor/github.com/hawkular/hawkular-client-go/metrics/types.go
+++ b/vendor/github.com/hawkular/hawkular-client-go/metrics/types.go
@@ -1,5 +1,5 @@
 /*
-   Copyright 2015-2016 Red Hat, Inc. and/or its affiliates
+   Copyright 2015-2017 Red Hat, Inc. and/or its affiliates
    and other contributors.
 
    Licensed under the Apache License, Version 2.0 (the "License");
@@ -20,9 +20,10 @@ package metrics
 import (
 	"crypto/tls"
 	"encoding/json"
-	"fmt"
+	// "fmt"
 	"net/http"
 	"net/url"
+	"time"
 )
 
 // HawkularClientError Extracted error information from Hawkular-Metrics server
@@ -31,22 +32,27 @@ type HawkularClientError struct {
 	Code int
 }
 
-// Parameters Initialization parameters to the client
+// Parameters is a struct used as initialization parameters to the client
 type Parameters struct {
 	Tenant      string // Technically optional, but requires setting Tenant() option everytime
 	Url         string
 	TLSConfig   *tls.Config
+	Username    string
+	Password    string
 	Token       string
 	Concurrency int
+	AdminToken  string
 }
 
-// Client HawkularClient's data structure
+// Client is HawkularClient's internal data structure
 type Client struct {
-	Tenant string
-	url    *url.URL
-	client *http.Client
-	Token  string
-	pool   chan (*poolRequest)
+	Tenant      string
+	url         *url.URL
+	client      *http.Client
+	Credentials string // base64 encoded username/password for Basic header
+	Token       string // authentication token for Bearer header
+	AdminToken  string // authentication for items behind admin token
+	pool        chan (*poolRequest)
 }
 
 type poolRequest struct {
@@ -59,7 +65,7 @@ type poolResponse struct {
 	resp *http.Response
 }
 
-// HawkularClient HawkularClient base type to define available functions..
+// HawkularClient is a base type to define available functions of the client
 type HawkularClient interface {
 	Send(*http.Request) (*http.Response, error)
 }
@@ -74,128 +80,125 @@ type Filter func(r *http.Request)
 type Endpoint func(u *url.URL)
 
 // MetricType restrictions
-type MetricType int
+type MetricType string
 
 const (
-	Gauge = iota
-	Availability
-	Counter
-	Generic
+	Gauge        MetricType = "gauge"
+	Availability            = "availability"
+	Counter                 = "counter"
+	Generic                 = "metrics"
+	String                  = "string"
 )
 
-var longForm = []string{
-	"gauges",
-	"availability",
-	"counters",
-	"metrics",
+// MetricHeader is the header struct for time series, which has identifiers (tenant, type, id) for uniqueness
+// and []Datapoint to describe the actual time series values.
+type MetricHeader struct {
+	Tenant string      `json:"-"`
+	Type   MetricType  `json:"-"`
+	ID     string      `json:"id"`
+	Data   []Datapoint `json:"data"`
 }
 
-var shortForm = []string{
-	"gauge",
-	"availability",
-	"counter",
-	"metrics",
+// Datapoint is a struct that represents a single time series value.
+// Value should be convertible to float64 for gauge/counter series.
+// Timestamp accuracy is milliseconds since epoch
+type Datapoint struct {
+	Timestamp time.Time         `json:"-"`
+	Value     interface{}       `json:"value"`
+	Tags      map[string]string `json:"tags,omitempty"`
 }
 
-func (mt MetricType) validate() error {
-	if int(mt) > len(longForm) && int(mt) > len(shortForm) {
-		return fmt.Errorf("Given MetricType value %d is not valid", mt)
-	}
-	return nil
-}
+// MarshalJSON is modified JSON marshalling for Datapoint object to modify time.Time to milliseconds since epoch
+func (d Datapoint) MarshalJSON() ([]byte, error) {
+	b, err := json.Marshal(map[string]interface{}{
+		"timestamp": ToUnixMilli(d.Timestamp),
+		"value":     d.Value,
+	})
 
-// String Get string representation of type
-func (mt MetricType) String() string {
-	if err := mt.validate(); err != nil {
-		return "unknown"
-	}
-	return longForm[mt]
+	return b, err
 }
 
-func (mt MetricType) shortForm() string {
-	if err := mt.validate(); err != nil {
-		return "unknown"
-	}
-	return shortForm[mt]
+// To avoid recursion in UnmarshalJSON
+type datapoint Datapoint
+
+type datapointJSON struct {
+	datapoint
+	Ts int64 `json:"timestamp"`
 }
 
-// UnmarshalJSON Custom unmarshaller for MetricType
-func (mt *MetricType) UnmarshalJSON(b []byte) error {
-	var f interface{}
-	err := json.Unmarshal(b, &f)
+// UnmarshalJSON is a custom unmarshaller for Datapoint for timestamp modifications
+func (d *Datapoint) UnmarshalJSON(b []byte) error {
+	dp := datapointJSON{}
+	err := json.Unmarshal(b, &dp)
 	if err != nil {
 		return err
 	}
 
-	if str, ok := f.(string); ok {
-		for i, v := range shortForm {
-			if str == v {
-				*mt = MetricType(i)
-				break
-			}
-		}
-	}
+	*d = Datapoint(dp.datapoint)
+	d.Timestamp = FromUnixMilli(dp.Ts)
 
 	return nil
 }
 
-// MarshalJSON Custom marshaller for MetricType
-func (mt MetricType) MarshalJSON() ([]byte, error) {
-	return json.Marshal(mt.String())
-}
-
-// Hawkular-Metrics external structs
-// Do I need external.. hmph.
-
-type MetricHeader struct {
-	Tenant string      `json:"-"`
-	Type   MetricType  `json:"-"`
-	Id     string      `json:"id"`
-	Data   []Datapoint `json:"data"`
-}
-
-// Datapoint Value should be convertible to float64 for numeric values, Timestamp is milliseconds since epoch
-type Datapoint struct {
-	Timestamp int64             `json:"timestamp"`
-	Value     interface{}       `json:"value"`
-	Tags      map[string]string `json:"tags,omitempty"`
-}
-
-// HawkularError Return payload from Hawkular-Metrics if processing failed
+// HawkularError is the return payload from Hawkular-Metrics if processing failed
 type HawkularError struct {
 	ErrorMsg string `json:"errorMsg"`
 }
 
+// MetricDefinition is a struct that describes the stored definition of a time serie
 type MetricDefinition struct {
 	Tenant        string            `json:"-"`
 	Type          MetricType        `json:"type,omitempty"`
-	Id            string            `json:"id"`
+	ID            string            `json:"id"`
 	Tags          map[string]string `json:"tags,omitempty"`
 	RetentionTime int               `json:"dataRetention,omitempty"`
 }
 
 // TODO Fix the Start & End to return a time.Time
 
-// Bucketpoint Return structure for bucketed data
+// Bucketpoint is a return structure for bucketed data requests (stats endpoint)
 type Bucketpoint struct {
-	Start       int64        `json:"start"`
-	End         int64        `json:"end"`
+	Start       time.Time    `json:"-"`
+	End         time.Time    `json:"-"`
 	Min         float64      `json:"min"`
 	Max         float64      `json:"max"`
 	Avg         float64      `json:"avg"`
 	Median      float64      `json:"median"`
 	Empty       bool         `json:"empty"`
-	Samples     int64        `json:"samples"`
+	Samples     uint64       `json:"samples"`
 	Percentiles []Percentile `json:"percentiles"`
 }
 
-// Percentile Hawkular-Metrics calculated percentiles representation
+type bucketpoint Bucketpoint
+
+type bucketpointJSON struct {
+	bucketpoint
+	StartTs int64 `json:"start"`
+	EndTs   int64 `json:"end"`
+}
+
+// UnmarshalJSON is a custom unmarshaller to transform int64 timestamps to time.Time
+func (b *Bucketpoint) UnmarshalJSON(payload []byte) error {
+	bp := bucketpointJSON{}
+	err := json.Unmarshal(payload, &bp)
+	if err != nil {
+		return err
+	}
+
+	*b = Bucketpoint(bp.bucketpoint)
+	b.Start = FromUnixMilli(bp.StartTs)
+	b.End = FromUnixMilli(bp.EndTs)
+
+	return nil
+}
+
+// Percentile is Hawkular-Metrics' estimated (not exact) percentile
 type Percentile struct {
 	Quantile float64 `json:"quantile"`
 	Value    float64 `json:"value"`
 }
 
-// Order Basetype for selecting the sorting of datapoints
+// Order is a basetype for selecting the sorting of requested datapoints
 type Order int
 
 const (
@@ -205,7 +208,7 @@ const (
 	DESC
 )
 
-// String Get string representation of type
+// String returns a string representation of type
 func (o Order) String() string {
 	switch o {
 	case ASC:
@@ -215,3 +218,9 @@ func (o Order) String() string {
 	}
 	return ""
 }
+
+// TenantDefinition is the structure that defines a tenant
+type TenantDefinition struct {
+	ID         string             `json:"id"`
+	Retentions map[MetricType]int `json:"retentions"`
+}
-- 
2.7.4

